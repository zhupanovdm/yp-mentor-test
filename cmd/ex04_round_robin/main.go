// Демонстрирует синхронизацию горутин с помощью каналов.
// Представим игру, в которую могут играть произвольное количество участников, ведущий загадывает число. Игроки
// становятся в круг, затем ведущий одному из игроков дает мяч, игрок называет число 1 и передает мяч игроку справа от
// себя, игрок принявший мяч должен назвать число на один больше названного и передать мяч другому игроку справа от себя
// и так далее - по кругу. Нельзя называть числа не по порядку. Игра продолжается до тех пор, пока один из игроков не
// досчитает до числа, загаданного ведущим. В этом случае он не передает мяч по кругу, а сообщает соседнему игроку, что
// игра окончена, тот в свою очередь своему соседу и т.д. пока каждый игрок не будет оповещен об окончании игры.
package main

import (
	"fmt"
	"time"
)

const (
	playersCount = 10   // Количество игроков в игре.
	targetNumber = 1024 // Загаданное ведущим число.
)

func main() {
	var player, first, next chan int

	first = make(chan int) // Первый игрок.
	player = first

	// Расставим игроков по кругу, чтобы они имели возможность передавать мяч по кругу.
	for number := 1; number < playersCount; number++ {
		next = make(chan int)
		go play(number, player, next, targetNumber)
		player = next
	}

	// Последний игрок должен передать мяч первому (закольцуем).
	go play(playersCount, next, first, targetNumber)

	// Ведущий передает игроку мяч. Игра начинается.
	first <- 1

	// Подождем.
	time.Sleep(time.Second)
}

// Определим правила игры.
func play(n int, player <-chan int, next chan<- int, target int) {
	for {
		// Ждем мяч.
		i, ok := <-player

		// Если достигнуто загаданное число или игрок узнал, что игра окончена - сообщим об этом соседнему игроку.
		if !ok || i == target {
			fmt.Printf("P%02d STOP!\n", n)
			close(next)
			return
		}

		// Игра продолжается - называем число.
		fmt.Printf("P%02d %10d\n", n, i)

		// Число для следующего игрока.
		next <- i + 1
	}
}
